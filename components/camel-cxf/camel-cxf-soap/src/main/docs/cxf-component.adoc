= CXF Component
:doctitle: CXF
:shortname: cxf
:artifactid: camel-cxf-soap
:description: Expose SOAP WebServices using Apache CXF or connect to external WebServices using CXF WS client.
:since: 1.0
:supportlevel: Stable
:tabs-sync-option:
:component-header: Both producer and consumer are supported
//Manually maintained attributes
:camel-spring-boot-name: cxf-soap

*Since Camel {since}*

*{component-header}*

The CXF component provides integration with http://cxf.apache.org[Apache CXF] for connecting to http://cxf.apache.org/docs/jax-ws.html[JAX-WS] services hosted in CXF.

[TIP]
====
When using CXF in streaming modes (see DataFormat option), then also read about Stream caching.
====

Maven users must add the following dependency to their `pom.xml` for this component:

.Example: `pom.xml`
[source,xml]
----
<dependency>
    <groupId>org.apache.camel</groupId>
    <artifactId>camel-cxf-soap</artifactId>
    <version>x.x.x</version>
    <!-- use the same version as your Camel core version -->
</dependency>
----

== URI format

There are two URI formats for this endpoint: *cxfEndpoint* and *someAddress*.

=== `cxfEndpoint`
----
cxf:bean:cxfEndpoint[?options]
----

*cxfEndpoint* represents a bean ID that references a bean in the
Spring bean registry. With this URI format, most of the endpoint details
are specified in the bean definition.

=== `someAddress`
----
cxf://someAddress[?options]
----

*someAddress* specifies the CXF endpoint's address. With this URI
format, most of the endpoint details are specified using options.

=== URI Options

For either URI format, you can append options to the URI as follows:

----
cxf:bean:cxfEndpoint?wsdlURL=wsdl/hello_world.wsdl&dataFormat=PAYLOAD
----


// component-configure options: START

// component-configure options: END

// component options: START
include::partial$component-configure-options.adoc[]
include::partial$component-endpoint-options.adoc[]
// component options: END

// endpoint options: START

// endpoint options: END

// component headers: START
include::partial$component-endpoint-headers.adoc[]
// component headers: END

[NOTE]
====
The `serviceName` and `portName` are http://en.wikipedia.org/wiki/QName[QNames], so if you provide them be sure to prefix them with their `\{namespace}` as shown in the examples above.
====

=== Descriptions of the dataformats

In Apache Camel, the Camel CXF component is the key to integrating routes with Web services. You can use the Camel CXF component to create a CXF endpoint, which can be used in either of the following ways:

* *Consumer* — (at the start of a route) represents a Web service instance, which integrates with the route. The type of payload injected into the route depends on the value of the endpoint's dataFormat option.
* *Producer* — (at other points in the route) represents a WS client proxy, which converts the current exchange object into an operation invocation on a remote Web service. The format of the current exchange must match the endpoint's dataFormat setting.

[width="100%",cols="10%,50,30%",options="header",]
|=======================================================================
|DataFormat |Description |Support

|`POJO` 
|Plain Old Java Objects are the Java parameters to the method being invoked on the target server. 
|Both Protocol and Logical JAX-WS handlers are supported.

|`PAYLOAD` 
|The message payload (the contents of the `soap:body`) after
message configuration in the CXF endpoint is applied. 
|Only Protocol JAX-WS handler is supported. Logical JAX-WS handler is not supported.

|`RAW` 
|Provides the raw message stream that is received from the transport layer.
It is not possible to touch or change the stream, some of the CXF
interceptors are removed if you are using this kind of DataFormat, so
you can't see any soap headers after the camel-cxf consumer. 
|JAX-WS handler is not supported. Note that `RAW` mode is equivalent to deprecated `MESSAGE` mode.

|`CXF_MESSAGE` 
|Allows for invoking the full capabilities of CXF interceptors by converting the message from the transport layer into a raw SOAP message
|

|=======================================================================

You can determine the data format mode of an exchange by retrieving the
exchange property, `CamelCXFDataFormat`. The exchange key constant is
defined in `org.apache.camel.component.cxf.common.message.CxfConstants.DATA_FORMAT_PROPERTY`.

== Creating a simple CXF service with POJO data format

If you  have a simple java web service interface and an implementation, you can create a  simple CXF service. 

.Example: Java web service interface
[source,java]
----
package org.apache.camel.component.cxf.soap.server;

@WebService(targetNamespace = "http://server.soap.cxf.component.camel.apache.org/", name = "EchoService")
public interface EchoService {

    String echo(String text);
}
----

.Example: Implementation
[source,java]
----

package org.apache.camel.component.cxf.soap.server;

@WebService(name = "EchoService", serviceName = "EchoService", targetNamespace = "http://server.soap.cxf.component.camel.apache.org/")
public class EchoServiceImpl implements EchoService {

    @Override
    public String echo(String text) {
        return text;
    }

}
----

[NOTE]
====
POJO mode is the default, so you do not have to specify it.
====

.Simple CXF service
[source,java]
----
    from("cxf:echoServiceResponseFromImpl?serviceClass=org.apache.camel.component.cxf.soap.server.EchoServiceImpl&address=/echo-impl")// no body set here; the response comes from EchoServiceImpl
                .log("${body}");
----

In a more complicated implementation of the service, you can set the body from the route instead:

.CXF service with body set from route
[source,java]
----
    from("cxf:echoServiceResponseFromRoute?serviceClass=org.apache.camel.component.cxf.soap.server.EchoServiceImpl&address=/echo-route")
                .setBody(exchange -> exchange.getMessage().getBody(String.class) + " from Camel route");
----

== Consuming a message from a `camel-cxf` endpoint in POJO data format

The `camel-cxf` endpoint consumer POJO data format is based on the
http://cxf.apache.org/docs/invokers.html[CXF invoker], so the
message header has a property with the name of `CxfConstants.OPERATION_NAME` and the message body is a list of the SEI method parameters.

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/wsdl_first/PersonProcessor.java[PersonProcessor]
[source,java]
----
public class PersonProcessor implements Processor {

    private static final Logger LOG = LoggerFactory.getLogger(PersonProcessor.class);

    @Override
    @SuppressWarnings("unchecked")
    public void process(Exchange exchange) throws Exception {
        LOG.info("processing exchange in camel");

        BindingOperationInfo boi = (BindingOperationInfo) exchange.getProperty(BindingOperationInfo.class.getName());
        if (boi != null) {
            LOG.info("boi.isUnwrapped" + boi.isUnwrapped());
        }
        // Get the parameters list which element is the holder.
        MessageContentsList msgList = (MessageContentsList) exchange.getIn().getBody();
        Holder<String> personId = (Holder<String>) msgList.get(0);
        Holder<String> ssn = (Holder<String>) msgList.get(1);
        Holder<String> name = (Holder<String>) msgList.get(2);

        if (personId.value == null || personId.value.length() == 0) {
            LOG.info("person id 123, so throwing exception");
            // Try to throw out the soap fault message
            org.apache.camel.wsdl_first.types.UnknownPersonFault personFault
                    = new org.apache.camel.wsdl_first.types.UnknownPersonFault();
            personFault.setPersonId("");
            org.apache.camel.wsdl_first.UnknownPersonFault fault
                    = new org.apache.camel.wsdl_first.UnknownPersonFault("Get the null value of person name", personFault);
            exchange.getMessage().setBody(fault);
            return;
        }

        name.value = "Bonjour";
        ssn.value = "123";
        LOG.info("setting Bonjour as the response");
        // Set the response message, first element is the return value of the operation,
        // the others are the holders of method parameters
        exchange.getMessage().setBody(new Object[] { null, personId, ssn, name });
    }

}
----

== Preparing the message for the `camel-cxf` endpoint in POJO data format

The `camel-cxf` endpoint producer is based on the
https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/endpoint/Client.java[CXF client API]. 

To prepare the message: 

. Specify the operation name in the message header. 
. Add the method parameters to a list.
. Initialize the  message with this parameter list.

The response message's body is a `messageContentsList`, so you can get the result from that list.

* If you do not specify the operation name in the message header, `CxfProducer` tries to use the `defaultOperationName` from `CxfEndpoint`. 

* If there is no `defaultOperationName` set on `CxfEndpoint`, it will pick up the first operationName from the Operation  list.

* If you want to get the object array from the message body, you can get
the body using `message.getBody(Object[].class)`, as shown here:
+
.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfProducerRouterTest.java#L117[CxfProducerRouterTest.testInvokingSimpleServerWithParams]
[source,java]
----
Exchange senderExchange = new DefaultExchange(context, ExchangePattern.InOut);
final List<String> params = new ArrayList<>();
// Prepare the request message for the camel-cxf procedure
params.add(TEST_MESSAGE);
senderExchange.getIn().setBody(params);
senderExchange.getIn().setHeader(CxfConstants.OPERATION_NAME, ECHO_OPERATION);

Exchange exchange = template.send("direct:EndpointA", senderExchange);

org.apache.camel.Message out = exchange.getMessage();
// The response message's body is an MessageContentsList which first element is the return value of the operation,
// If there are some holder parameters, the holder parameter is filled in the reset of List.
// The result is extracted from the MessageContentsList with the String class type
MessageContentsList result = (MessageContentsList) out.getBody();
LOG.info("Received output text: " + result.get(0));
Map<String, Object> responseContext = CastUtils.cast((Map<?, ?>) out.getHeader(Client.RESPONSE_CONTEXT));
assertNotNull(responseContext);
assertEquals("UTF-8", responseContext.get(org.apache.cxf.message.Message.ENCODING),
        "We should get the response context here");
assertEquals("echo " + TEST_MESSAGE, result.get(0), "Reply body on Camel is wrong");
----

== Consuming a message from a camel-cxf endpoint in PAYLOAD data format

PAYLOAD means that you process the payload from the SOAP envelope as a native CxfPayload. `Message.getBody()` will return a `org.apache.camel.component.cxf.CxfPayload` object, with getters for SOAP message headers and the SOAP body.

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfConsumerPayloadTest.java#L68[CxfConsumerPayloadTest]
[source,java]
----
protected RouteBuilder createRouteBuilder() {
    return new RouteBuilder() {
        public void configure() {
            from(simpleEndpointURI + "&dataFormat=PAYLOAD").to("log:info").process(new Processor() {
                @SuppressWarnings("unchecked")
                public void process(final Exchange exchange) throws Exception {
                    CxfPayload<SoapHeader> requestPayload = exchange.getIn().getBody(CxfPayload.class);
                    List<Source> inElements = requestPayload.getBodySources();
                    List<Source> outElements = new ArrayList<>();
                    // You can use a customer toStringConverter to turn a CxfPayLoad message into String as you want
                    String request = exchange.getIn().getBody(String.class);
                    XmlConverter converter = new XmlConverter();
                    String documentString = ECHO_RESPONSE;

                    Element in = new XmlConverter().toDOMElement(inElements.get(0));
                    // Just check the element namespace
                    if (!in.getNamespaceURI().equals(ELEMENT_NAMESPACE)) {
                        throw new IllegalArgumentException("Wrong element namespace");
                    }
                    if (in.getLocalName().equals("echoBoolean")) {
                        documentString = ECHO_BOOLEAN_RESPONSE;
                        checkRequest("ECHO_BOOLEAN_REQUEST", request);
                    } else {
                        documentString = ECHO_RESPONSE;
                        checkRequest("ECHO_REQUEST", request);
                    }
                    Document outDocument = converter.toDOMDocument(documentString, exchange);
                    outElements.add(new DOMSource(outDocument.getDocumentElement()));
                    // set the payload header with null
                    CxfPayload<SoapHeader> responsePayload = new CxfPayload<>(null, outElements, null);
                    exchange.getMessage().setBody(responsePayload);
                }
            });
        }
    };
}
----

== Getting and setting SOAP headers in POJO mode

POJO means that the data format is a list of Java objects when the `camel-cxf` endpoint produces or consumes Camel exchanges. Even though Camel exposes the message body as POJOs in this mode, `camel-cxf` still provides access to read and write SOAP headers. 

However, since CXF interceptors remove in-band SOAP headers from the header list after they have been processed, only out-of-band SOAP headers are available to `camel-cxf` in POJO mode.

The following example illustrates how to get and set SOAP headers. If you have a route that forwards from one `camel-cxf` endpoint to another, such as SOAP Client -> Camel -> CXF service, you can attach two processors to obtain/insert SOAP headers:

. Before a request goes out to the CXF service.
. Before the response comes back to the SOAP Client. 

Processor (1) and (2) in this example are `InsertRequestOutHeaderProcessor` and  `InsertResponseOutHeaderProcessor`:

.Example: Route for SOAP headers
[tabs]
====
Java::
+
[source,java]
----
from("cxf:bean:routerRelayEndpointWithInsertion")
    .process(new InsertRequestOutHeaderProcessor())
    .to("cxf:bean:serviceRelayEndpointWithInsertion")
    .process(new InsertResponseOutHeaderProcessor());
----

XML::
+
[source,xml]
----
<route>
    <from uri="cxf:bean:routerRelayEndpointWithInsertion"/> // <1>
    <process ref="InsertRequestOutHeaderProcessor" />
    <to uri="cxf:bean:serviceRelayEndpointWithInsertion"/> // <2>
    <process ref="InsertResponseOutHeaderProcessor" />
</route>
----

====

SOAP headers are propagated to and from Camel Message headers. 

* The Camel message header name is `org.apache.cxf.headers.Header.list` which is a constant defined in CXF (`org.apache.cxf.headers.Header.HEADER_LIST`). 

* The header value is a List of CXF SoapHeader objects (`org.apache.cxf.binding.soap.SoapHeader`).

You can access SOAP headers in the same way in both `InsertResponseOutHeaderProcessor` and `InsertRequestOutHeaderProcessor`. The only difference between the two processors is the direction of the inserted SOAP header.

The following snippet is the `InsertResponseOutHeaderProcessor` (that inserts a new SOAP header in the response message) example:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-spring-soap/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java#L731[CxfMessageHeadersRelayTest]
[source,java]
----
public static class InsertResponseOutHeaderProcessor implements Processor {

    public void process(Exchange exchange) throws Exception {
        List<SoapHeader> soapHeaders = CastUtils.cast((List<?>)exchange.getIn().getHeader(Header.HEADER_LIST));

        // Insert a new header
        String xml = "<?xml version=\"1.0\" encoding=\"utf-8\"?><outofbandHeader "
            + "xmlns=\"http://cxf.apache.org/outofband/Header\" hdrAttribute=\"testHdrAttribute\" "
            + "xmlns:soap=\"http://schemas.xmlsoap.org/soap/envelope/\" soap:mustUnderstand=\"1\">"
            + "<name>New_testOobHeader</name><value>New_testOobHeaderValue</value></outofbandHeader>";
        SoapHeader newHeader = new SoapHeader(soapHeaders.get(0).getName(),
                       DOMUtils.readXml(new StringReader(xml)).getDocumentElement());
        // ensure the direction is OUT since it is a response message.
        newHeader.setDirection(Direction.DIRECTION_OUT);
        //newHeader.setMustUnderstand(false);
        soapHeaders.add(newHeader);

    }

}
----

== Getting and setting SOAP headers in PAYLOAD mode

You can see how to access the SOAP message as a `CxfPayload` object in
PAYLOAD mode in the section <<_consuming_a_message_from_a_camel_cxf_endpoint_in_payload_data_format>>.

Once you obtain a `CxfPayload` object, you can invoke the `CxfPayload.getHeaders()` method that returns a List of `DOM` Elements (SOAP headers).

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfPayLoadSoapHeaderTest.java#L53[CxfPayLoadSoapHeaderTest]
[source,java]
----
from(getRouterEndpointURI()).process(new Processor() {
    @SuppressWarnings("unchecked")
    public void process(Exchange exchange) throws Exception {
        CxfPayload<SoapHeader> payload = exchange.getIn().getBody(CxfPayload.class);
        List<Source> elements = payload.getBodySources();
        assertNotNull(elements, "We should get the elements here");
        assertEquals(1, elements.size(), "Get the wrong elements size");

        Element el = new XmlConverter().toDOMElement(elements.get(0));
        elements.set(0, new DOMSource(el));
        assertEquals("http://camel.apache.org/pizza/types",
                el.getNamespaceURI(), "Get the wrong namespace URI");

        List<SoapHeader> headers = payload.getHeaders();
        assertNotNull(headers, "We should get the headers here");
        assertEquals(1, headers.size(), "Get the wrong headers size");
        assertEquals("http://camel.apache.org/pizza/types",
                ((Element) (headers.get(0).getObject())).getNamespaceURI(), "Get the wrong namespace URI");
        // alternatively you can also get the SOAP header via the camel header:
        headers = exchange.getIn().getHeader(Header.HEADER_LIST, List.class);
        assertNotNull(headers, "We should get the headers here");
        assertEquals(1, headers.size(), "Get the wrong headers size");
        assertEquals("http://camel.apache.org/pizza/types",
                ((Element) (headers.get(0).getObject())).getNamespaceURI(), "Get the wrong namespace URI");

    }

})
.to(getServiceEndpointURI());
----

You can also use the method described in the section <<_getting_and_setting_soap_headers_in_payload_mode>> to set or get
the SOAP headers. 

You can use the header `org.apache.cxf.headers.Header.list` to get and set a list of SOAP headers. This does also mean that if you have a route that forwards  from one `camel-cxf` endpoint to another (SOAP Client -> Camel -> CXF  service), now also the SOAP headers sent by the SOAP client are forwarded to the CXF service. 

If you do not want to forward the headers you have to remove them in the Camel header `org.apache.cxf.headers.Header.list`.

== SOAP headers are not available in RAW mode

SOAP headers are not available in RAW mode as SOAP processing is skipped.

== Throwing a SOAP Fault from Camel

If you are using a `camel-cxf` endpoint to consume the SOAP request, you  may need to throw the SOAP Fault from the Camel context.  You can use the `throwFault` DSL to do that; it works for `POJO`, `PAYLOAD` and `RAW` data format. 
 
You can define the soap fault as shown here:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfCustomizedExceptionTest.java#L65[CxfCustomizedExceptionTest]
[source,java]
----
SOAP_FAULT = new SoapFault(EXCEPTION_MESSAGE, SoapFault.FAULT_CODE_CLIENT);
Element detail = SOAP_FAULT.getOrCreateDetail();
Document doc = detail.getOwnerDocument();
Text tn = doc.createTextNode(DETAIL_TEXT);
detail.appendChild(tn);
----

You can define the SOAP fault as shown here:

.Example: Throwing the SOAP fault
[source,java]
----
from(routerEndpointURI).setFaultBody(constant(SOAP_FAULT));
----

If your CXF endpoint is working in the `RAW` data format, you can set the `SOAP Fault` message in the message body and set the response code in the message header as demonstrated here:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfMessageStreamExceptionTest.java#L43[CxfMessageStreamExceptionTest]
[source,java]
----
from(routerEndpointURI).process(new Processor() {

    public void process(Exchange exchange) throws Exception {
        Message out = exchange.getMessage();
        // Set the message body with the
        out.setBody(this.getClass().getResourceAsStream("SoapFaultMessage.xml"));
        // Set the response code here
        out.setHeader(org.apache.cxf.message.Message.RESPONSE_CODE, new Integer(500));
    }

});
----

In the `POJO` data format you can set the `SOAPFault` on the out body.

[#propagate-request-response-context]
== Propagating a `camel-cxf` endpoint's request and response context

The https://github.com/apache/cxf/blob/master/core/src/main/java/org/apache/cxf/endpoint/Client.java[CXF client API] provides a way to invoke the operation with request and
response context. If you are using a `camel-cxf` endpoint producer to
invoke the outside web service, you can set the request context and get
response context with the following code:

.Example: Setting the request context and getting the response context
[source,java]
----
CxfExchange exchange = (CxfExchange)template.send(getJaxwsEndpointUri(), new Processor() {
     public void process(final Exchange exchange) {
         final List<String> params = new ArrayList<String>();
         params.add(TEST_MESSAGE);
         // Set the request context to the inMessage
         Map<String, Object> requestContext = new HashMap<String, Object>();
         requestContext.put(BindingProvider.ENDPOINT_ADDRESS_PROPERTY, JAXWS_SERVER_ADDRESS);
         exchange.getIn().setBody(params);
         exchange.getIn().setHeader(Client.REQUEST_CONTEXT , requestContext);
         exchange.getIn().setHeader(CxfConstants.OPERATION_NAME, GREET_ME_OPERATION);
     }
});
org.apache.camel.Message out = exchange.getMessage();
// The output is an object array, the first element of the array is the return value
Object\[\] output = out.getBody(Object\[\].class);
LOG.info("Received output text: " + output\[0\]);
// Get the response context form outMessage
Map<String, Object> responseContext = CastUtils.cast((Map)out.getHeader(Client.RESPONSE_CONTEXT));
assertNotNull(responseContext);
assertEquals("Get the wrong wsdl operation name", "{http://apache.org/hello_world_soap_http}greetMe",
    responseContext.get("javax.xml.ws.wsdl.operation").toString());
----

== Attachment Support

=== POJO Mode
In *POJO Mode*, Message Transmission Optimization Mechanism (MTOM) is supported if it is enabled. See <<set-the-cxf-endpoint-property>> in Payload Mode. 

[source,java]
----
DataHandler Exchange.getIn(AttachmentMessage.class).getAttachment(String id)
----

=== Payload Mode
In *Payload Mode*, Message Transmission Optimization Mechanism (MTOM) is supported. 
Attachments can be retrieved through the Camel Message API. 
SOAP with Attachment (SwA) is supported and attachments can be retrieved. 
SwA is the default, as the default setting for CXF endpoint property `mtom-enabled` is `false`. 

To enable MTOM, set the CXF endpoint property `mtom-enabled` to `true`.

[#set-the-cxf-endpoint-property]
.Example: Setting the CXF endpoint property
[tabs]
====
Java (Quarkus)::
+
[source,java]
----
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.cxf.common.DataFormat;
import org.apache.camel.component.cxf.jaxws.CxfEndpoint;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.enterprise.context.SessionScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Named;

@ApplicationScoped
public class CxfSoapMtomRoutes extends RouteBuilder {

    @Override
    public void configure() {
        from("cxf:bean:mtomPayloadModeEndpoint")
                .process( exchange -> { ... });
    }

    @Produces
    @SessionScoped
    @Named
    CxfEndpoint mtomPayloadModeEndpoint() {
        final CxfEndpoint result = new CxfEndpoint();
        result.setServiceClass(MyMtomService.class);
        result.setDataFormat(DataFormat.PAYLOAD);
        result.setMtomEnabled(true);
        result.setAddress("/mtom/hello");
        return result;
    }
}
----

XML (Spring)::
+
[source,xml]
----
<cxf:cxfEndpoint id="mtomPayloadModeEndpoint" address="http://localhost:${CXFTestSupport.port1}/CxfMtomRouterPayloadModeTest/mtom"
        wsdlURL="mtom.wsdl"
        serviceName="ns:MyMtomService"
        endpointName="ns:MyMtomPort"
        xmlns:ns="http://apache.org/camel/cxf/mtom_feature">

    <cxf:properties>
        <!--  enable mtom by setting this property to true -->
        <entry key="mtom-enabled" value="true"/>
        <!--  set the camel-cxf endpoint data fromat to PAYLOAD mode -->
        <entry key="dataFormat" value="PAYLOAD"/>
    </cxf:properties>
</cxf:cxfEndpoint>
----
====

You can produce a Camel message with attachment to send to a CXF endpoint in *Payload mode*::

[source,java]
----
Exchange exchange = context.createProducerTemplate().send("direct:testEndpoint", new Processor() {

    public void process(Exchange exchange) throws Exception {
        exchange.setPattern(ExchangePattern.InOut);
        List<Source> elements = new ArrayList<Source>();
        elements.add(new DOMSource(DOMUtils.readXml(new StringReader(MtomTestHelper.REQ_MESSAGE)).getDocumentElement()));
        CxfPayload<SoapHeader> body = new CxfPayload<SoapHeader>(new ArrayList<SoapHeader>(),
            elements, null);
        exchange.getIn().setBody(body);
        exchange.getIn(AttachmentMessage.class).addAttachment(MtomTestHelper.REQ_PHOTO_CID,
            new DataHandler(new ByteArrayDataSource(MtomTestHelper.REQ_PHOTO_DATA, "application/octet-stream")));

        exchange.getIn(AttachmentMessage.class).addAttachment(MtomTestHelper.REQ_IMAGE_CID,
            new DataHandler(new ByteArrayDataSource(MtomTestHelper.requestJpeg, "image/jpeg")));

    }

});

// process response

CxfPayload<SoapHeader> out = exchange.getMessage().getBody(CxfPayload.class);
assertEquals(1, out.getBody().size());

Map<String, String> ns = new HashMap<>();
ns.put("ns", MtomTestHelper.SERVICE_TYPES_NS);
ns.put("xop", MtomTestHelper.XOP_NS);

XPathUtils xu = new XPathUtils(ns);
Element oute = new XmlConverter().toDOMElement(out.getBody().get(0));
Element ele = (Element) xu.getValue("//ns:DetailResponse/ns:photo/xop:Include", oute,
                XPathConstants.NODE);
String photoId = ele.getAttribute("href").substring(4); // skip "cid:"

ele = (Element) xu.getValue("//ns:DetailResponse/ns:image/xop:Include", oute,
                XPathConstants.NODE);
String imageId = ele.getAttribute("href").substring(4); // skip "cid:"

DataHandler dr = exchange.getMessage(AttachmentMessage.class).getAttachment(decodingReference(photoId));
assertEquals("application/octet-stream", dr.getContentType());
assertArrayEquals(MtomTestHelper.RESP_PHOTO_DATA, IOUtils.readBytesFromStream(dr.getInputStream()));

dr = exchange.getMessage(AttachmentMessage.class).getAttachment(decodingReference(imageId));
assertEquals("image/jpeg", dr.getContentType());

BufferedImage image = ImageIO.read(dr.getInputStream());
assertEquals(560, image.getWidth());
assertEquals(300, image.getHeight());
----

[#retrieve-attachments-camel-message-api]
You can also consume a Camel message received from a CXF endpoint in *Payload mode*:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-spring-soap/src/test/java/org/apache/camel/component/cxf/mtom/CxfMtomConsumerPayloadModeTest.java#L97[CxfMtomConsumerPayloadModeTest] 
[source,java]
----
public static class MyProcessor implements Processor {

    @Override
    @SuppressWarnings("unchecked")
    public void process(Exchange exchange) throws Exception {
        CxfPayload<SoapHeader> in = exchange.getIn().getBody(CxfPayload.class);

        // verify request
        assertEquals(1, in.getBody().size());

        Map<String, String> ns = new HashMap<>();
        ns.put("ns", MtomTestHelper.SERVICE_TYPES_NS);
        ns.put("xop", MtomTestHelper.XOP_NS);

        XPathUtils xu = new XPathUtils(ns);
        Element body = new XmlConverter().toDOMElement(in.getBody().get(0));
        Element ele = (Element) xu.getValue("//ns:Detail/ns:photo/xop:Include", body,
                XPathConstants.NODE);
        String photoId = ele.getAttribute("href").substring(4); // skip "cid:"
        assertEquals(MtomTestHelper.REQ_PHOTO_CID, photoId);

        ele = (Element) xu.getValue("//ns:Detail/ns:image/xop:Include", body,
                XPathConstants.NODE);
        String imageId = ele.getAttribute("href").substring(4); // skip "cid:"
        assertEquals(MtomTestHelper.REQ_IMAGE_CID, imageId);

        DataHandler dr = exchange.getIn(AttachmentMessage.class).getAttachment(photoId);
        assertEquals("application/octet-stream", dr.getContentType());
        assertArrayEquals(MtomTestHelper.REQ_PHOTO_DATA, IOUtils.readBytesFromStream(dr.getInputStream()));

        dr = exchange.getIn(AttachmentMessage.class).getAttachment(imageId);
        assertEquals("image/jpeg", dr.getContentType());
        assertArrayEquals(MtomTestHelper.requestJpeg, IOUtils.readBytesFromStream(dr.getInputStream()));

        // create response
        List<Source> elements = new ArrayList<>();
        elements.add(new DOMSource(StaxUtils.read(new StringReader(MtomTestHelper.RESP_MESSAGE)).getDocumentElement()));
        CxfPayload<SoapHeader> sbody = new CxfPayload<>(
                new ArrayList<SoapHeader>(),
                elements, null);
        exchange.getMessage().setBody(sbody);
        exchange.getMessage(AttachmentMessage.class).addAttachment(MtomTestHelper.RESP_PHOTO_CID,
                new DataHandler(new ByteArrayDataSource(MtomTestHelper.RESP_PHOTO_DATA, "application/octet-stream")));

        exchange.getMessage(AttachmentMessage.class).addAttachment(MtomTestHelper.RESP_IMAGE_CID,
                new DataHandler(new ByteArrayDataSource(MtomTestHelper.responseJpeg, "image/jpeg")));

    }
}
----

=== RAW Mode
In *RAW Mode*, attachments are not supported as it does not process the message at all.

=== CXF_MESSAGE Mode
In *CXF_MESSAGE Mode*, MTOM is supported, and Attachments can be retrieved
by Camel Message APIs (see <<retrieve-attachments-camel-message-api>>). Note that when receiving a multipart that is, a MTOM message, the default *SOAPMessage to String* converter will provide the complete multipart payload in the body. If
you require just the SOAP XML as a String, you can set the message body with `message.getSOAPPart()`, and *Camel convert* can do the rest of work for you.

== Streaming Support in PAYLOAD mode

The `camel-cxf` component supports streaming of incoming messages when using PAYLOAD mode.

The incoming messages can remain as a `javax.xml.transform.Source` while  being routed and, if nothing modifies the payload, can then be directly  streamed out to the target destination. 

For a simple proxy (such as `from("cxf:...").to("cxf:...")`), this provides significant improvements in performance and memory requirements.

However, there are cases where streaming may not be appropriate or desired. Due to the streaming nature, invalid incoming XML may not be caught until later in the processing chain. Also, certain actions may require the message to be `DOM` parsed anyway (for example `WS-Security` or message tracing) in which case the advantages of the streaming is limited. 

=== Controlling streaming in PAYLOAD mode
You can control the streaming in several ways:

* *Endpoint property*: you can add `allowStreaming=false` as an endpoint property to turn the streaming on or off.

* *Component property*: the `CxfComponent` object has an `allowStreaming`
property that can set the default for endpoints created from that component.

* *Global system property*: you can add a system property to `org.apache.camel.component.cxf.streaming` to `false` to turn it off. That sets the global default, but the endpoint property will override this value (for that endpoint only).

[NOTE]
====
Parsing incoming messages with `DOM` can require a lot of memory and time for large messages.
====

== Using the generic CXF Dispatch mode

The `camel-cxf` component supports the generic https://cxf.apache.org/docs/jax-ws-dispatch-api.html[CXF dispatch mode] that can transport messages of arbitrary structures (that is not bound to a specific XML schema). To use this mode, you simply omit specifying the `wsdlURL` and `serviceClass` attributes of the CXF endpoint.

.Example: Endpoint in PAYLOAD mode
[source,xml]
----
<cxf:cxfEndpoint id="dispatchEndpoint" address="http://localhost:9000/SoapContext/SoapAnyPort">
    <cxf:properties>
        <entry key="dataFormat" value="PAYLOAD"/>
    </cxf:properties>
</cxf:cxfEndpoint>
----

[NOTE]
====
The default CXF dispatch client does not send a specific `SOAPAction` header. Therefore, when the target service requires a specific `SOAPAction` value, you supply it in the Camel header using the key `SOAPAction` (case-insensitive).
====

[#cxf-loggingout-interceptor-in-message-mode]
=== Enabling CXF's LoggingOutInterceptor in RAW mode

CXF's `LoggingOutInterceptor` outputs an outbound message that goes on the wire to logging system (Java Util Logging). 

Since the `LoggingOutInterceptor` is in `PRE_STREAM` phase, and the `PRE_STREAM` phase is removed in `RAW` mode, you have to configure `LoggingOutInterceptor` to be run during the `WRITE` phase:

.Example: `LoggingOutInterceptor` in `RAW` mode
[tabs]
====
Java (Quarkus)::
+
[source,java]
----
import java.util.List;
import org.apache.camel.builder.RouteBuilder;
import org.apache.camel.component.cxf.common.DataFormat;
import org.apache.camel.component.cxf.jaxws.CxfEndpoint;
import org.apache.cxf.interceptor.LoggingOutInterceptor;
import org.apache.cxf.phase.Phase;
import jakarta.enterprise.context.SessionScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Named;

...

@Produces
@SessionScoped
@Named
CxfEndpoint soapMtomEnabledServerPayloadModeEndpoint() {
    final CxfEndpoint result = new CxfEndpoint();
    result.setServiceClass(HelloService.class);
    result.setDataFormat(DataFormat.RAW);
    result.setOutFaultInterceptors(List.of(new LoggingOutInterceptor(Phase.WRITE)));;
    result.setAddress("/helloworld");
    return result;
}
----

XML (Spring)::
+
[source,xml]
----
<bean id="loggingOutInterceptor" class="org.apache.cxf.interceptor.LoggingOutInterceptor">
    <!--  it really should have been user-prestream but CXF does have such phase! -->
    <constructor-arg value="write"/>
</bean>

<cxf:cxfEndpoint id="serviceEndpoint" address="http://localhost:${CXFTestSupport.port2}/LoggingInterceptorInMessageModeTest/helloworld"
    serviceClass="org.apache.camel.component.cxf.HelloService">
    <cxf:outInterceptors>
        <ref bean="loggingOutInterceptor"/>
    </cxf:outInterceptors>
    <cxf:properties>
        <entry key="dataFormat" value="RAW"/>
    </cxf:properties>
</cxf:cxfEndpoint>
----
====

=== The `relayHeaders` option

There are _in-band_ and _out-of-band_ on-the-wire headers from the
perspective of a JAXWS WSDL-first developer.

The _in-band_ headers are headers that you define explicitly as part of the WSDL binding contract for an endpoint such as SOAP headers.

The _out-of-band_ headers are headers that you serialize over the wire, but they are not explicitly part of the WSDL binding contract.

Headers relaying/filtering is bi-directional.

When a route has a CXF endpoint, and you need on-the-wire headers (such as SOAP headers) relayed along the route to be consumed by for example another JAXWS endpoint, you must set `relayHeaders` to `true`, the default value.

=== Available only in POJO mode

The `relayHeaders=true` expresses an intent to relay the headers. The actual decision whether a given header is relayed is delegated to a pluggable instance that implements the `MessageHeadersRelay` interface. 

A concrete implementation of `MessageHeadersRelay` is consulted to decide if a header needs to be relayed or not. There is already an implementation of `SoapMessageHeadersRelay` which binds itself to well-known SOAP name spaces. Currently only out-of-band headers are filtered, and in-band headers will always be relayed when `relayHeaders=true`. 

If there is a header on the wire whose name space is unknown to the runtime, then a fallback `DefaultMessageHeadersRelay` is used, which simply allows all headers to be relayed. 

The `relayHeaders=false` setting specifies that all headers in-band and out-of-band should be dropped.

You can plug in your own `MessageHeadersRelay` implementations, overriding or adding additional ones to the list of relays. In order to override a preloaded relay instance just ensure that your `MessageHeadersRelay` implementation services the same name spaces as the one you want to override. 

[NOTE]
====
The overriding relay has to service _all the name spaces_ as the one you want to override, or else this introduces an ambiguity in the name space to relay instance mappings, and a runtime exception is thrown on route startup.
====

.Example: `MessageHeadersRelay`
[source,xml]
----
<cxf:cxfEndpoint ...>
   <cxf:properties>
     <entry key="org.apache.camel.cxf.message.headers.relays">
       <list>
         <ref bean="customHeadersRelay"/>
       </list>
     </entry>
   </cxf:properties>
 </cxf:cxfEndpoint>
 <bean id="customHeadersRelay" class="org.apache.camel.component.cxf.soap.headers.CustomHeadersRelay"/>
----

You can find tests that show how you can relay/drop headers here:

* https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-spring-soap/src/test/java/org/apache/camel/component/cxf/soap/headers/CxfMessageHeadersRelayTest.java[CxfMessageHeadersRelayTest]

`POJO` and `PAYLOAD` modes are supported. 

In `POJO` mode, only out-of-band message headers are available for filtering as the in-band headers have been processed and removed from header list by CXF. The in-band headers are incorporated into the `MessageContentList` in POJO mode. 

The `camel-cxf` component does not make any attempt to remove the in-band headers from the `MessageContentList`. If you require filtering of in-band headers, use `PAYLOAD` mode or plug in a CXF interceptor/JAXWS Handler to the CXF endpoint.

==== The Message Header Relay mechanism in POJO mode

The Message Header Relay mechanism is part of the `CxfHeaderFilterStrategy` and is a property of `CxfHeaderFilterStrategy`. 

Here is an example of how you can configure it:

.Example: Message Header Relay configuration
[source,xml]
----
<bean id="dropAllMessageHeadersStrategy" class="org.apache.camel.component.cxf.transport.header.CxfHeaderFilterStrategy">

    <!--  Set relayHeaders to false to drop all SOAP headers -->
    <property name="relayHeaders" value="false"/>

</bean>
----

When you have configured the strategy, you can reference the `CxfHeaderFilterStrategy` in your endpoint.

.Example: Referencing the `CxfHeaderFilterStrategy`.
[source,xml]
----
<route>
    <from uri="cxf:bean:routerNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy"/>
    <to uri="cxf:bean:serviceNoRelayEndpoint?headerFilterStrategy=#dropAllMessageHeadersStrategy"/>
</route>
----

The `MessageHeaderFilter` interface (previously called `MessageHeadersRelay`) is a property of `CxfHeaderFilterStrategy`. Here is an example of configuring user
defined Message Header Filters:

.Example: Message Header Filters configuration
[source,xml]
----
<bean id="customMessageFilterStrategy" class="org.apache.camel.component.cxf.transport.header.CxfHeaderFilterStrategy">
    <property name="messageHeaderFilters">
        <list>
            <!--  SoapMessageHeaderFilter is the built-in filter.  It can be removed by omitting it. -->
            <bean class="org.apache.camel.component.cxf.common.header.SoapMessageHeaderFilter"/>

            <!--  Add custom filter here -->
            <bean class="org.apache.camel.component.cxf.soap.headers.CustomHeaderFilter"/>
        </list>
    </property>
</bean>
----

In addition to `relayHeaders`, you can configure the following properties in `CxfHeaderFilterStrategy`.

[width="100%",cols="10%,10%,40%,10%,10%",options="header",]
|=======================================================================
|Name |Required |Description|Type|Default

|`relayHeaders` 
|No 
|All message headers are processed by Message Header Filters.
|`boolean`
|`true`

|`relayAllMessageHeaders` 
| No 
|All message headers are propagated (without processing by Message
Header Filters).
|`boolean`
|`false`

|`allowFilterNamespaceClash` 
|No 
|If two filters overlap in activation namespace, the property control how
it should be handled. If the value is `true`, last one wins. If the
value is `false`, it will throw an exception.
|`boolean`
|`false`

|=======================================================================

== Making the camel-cxf component use log4j instead of java.util.logging

CXF's default logger is `java.util.logging`. 

To change the default logger to `log4j`, proceed as follows: 

. Create a file in the classpath, named `META-INF/cxf/org.apache.cxf.logger`
. Add a single line, with no comments, with the fully-qualified name of the class  (`org.apache.cxf.common.logging.Log4jLogger`).

== Letting camel-cxf response start with xml processing instruction

CXF does not add the XML processing instruction `<?xml version="1.0" encoding="utf-8"?>`. This can cause this type of error for some SOAP clients (for example PHP):

[source]
----
Error:sendSms: SoapFault exception: [Client] looks like we got no XML document in [...]
----

To resolve this issue, you must tell `StaxOutInterceptor` to write the XML start document for you, as in this example:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/WriteXmlDeclarationInterceptor.java[WriteXmlDeclarationInterceptor] 
[source,java]
----
public class WriteXmlDeclarationInterceptor extends AbstractPhaseInterceptor<SoapMessage> {
    public WriteXmlDeclarationInterceptor() {
        super(Phase.PRE_STREAM);
        addBefore(StaxOutInterceptor.class.getName());
    }

    public void handleMessage(SoapMessage message) throws Fault {
        message.put("org.apache.cxf.stax.force-start-document", Boolean.TRUE);
    }

}
----

As an alternative you can add a message header for it as demonstrated here:

.Example: https://github.com/apache/camel/blob/main/components/camel-cxf/camel-cxf-soap/src/test/java/org/apache/camel/component/cxf/jaxws/CxfConsumerTest.java#L62[CxfConsumerTest]
[source,java]
----
 // set up the response context which force start document
 Map<String, Object> map = new HashMap<String, Object>();
 map.put("org.apache.cxf.stax.force-start-document", Boolean.TRUE);
 exchange.getMessage().setHeader(Client.RESPONSE_CONTEXT, map);
----

== Configuring the CXF endpoints with Spring

You can configure the CXF endpoint with the Spring configuration file shown below.

You can also embed the endpoint into the `camelContext` tags. 

When you invoke the service endpoint, you can set the `operationName` and `operationNamespace` headers to explicitly state which operation you are calling.

.Example: Spring configuration
[source,xml]
----
<beans xmlns="http://www.springframework.org/schema/beans"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xmlns:cxf="http://camel.apache.org/schema/cxf"
        xsi:schemaLocation="
        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://camel.apache.org/schema/cxf http://camel.apache.org/schema/cxf/camel-cxf.xsd
        http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd">
     <cxf:cxfEndpoint id="routerEndpoint" address="http://localhost:9003/CamelContext/RouterPort"
            serviceClass="org.apache.hello_world_soap_http.GreeterImpl"/>
     <cxf:cxfEndpoint id="serviceEndpoint" address="http://localhost:9000/SoapContext/SoapPort"
            wsdlURL="testutils/hello_world.wsdl"
            serviceClass="org.apache.hello_world_soap_http.Greeter"
            endpointName="s:SoapPort"
            serviceName="s:SOAPService"
        xmlns:s="http://apache.org/hello_world_soap_http" />
     <camelContext id="camel" xmlns="http://camel.apache.org/schema/spring">
       <route>
         <from uri="cxf:bean:routerEndpoint" />
         <to uri="cxf:bean:serviceEndpoint" />
       </route>
    </camelContext>
  </beans>
----

The namespace declarations at the end of the `<cxf:cxfEndpoint/>` tag are required.

The combined `\{namespace}localName` syntax is not supported for this tag's attribute values.
====

The `cxf:cxfEndpoint` element supports many additional attributes:

[width="100%",cols="20%,40%,40%",options="header",]
|=======================================================================
|Name |Value |Format

|`PortName`
|The endpoint name this service is implementing. It maps to the `wsdl:port@name`. 
|`ns:PORT_NAME` where `ns` is a namespace prefix valid at this scope.

|`serviceName`
|The service name this service is implementing. It maps to the `wsdl:service@name`. 
|`ns:SERVICE_NAME` where `ns` is a namespace prefix valid at this scope.

|`wsdlURL`
|The location of the WSDL. 
|The classpath, file system, or remote host.

|`bindingId`
|The `bindingId` for the service model.
|

|`address`
|The service publish address.
|

|`bus`
|The bus name used in the JAX-WS endpoint.
|

|`serviceClass`
|Name of the SEI (Service Endpoint Interface) class, with or without JSR181 annotation.
|A class name 

|=======================================================================

It also supports many child elements:

[width="100%",cols="20%,40%,40%",options="header",]
|=======================================================================
|Name |Content |Value

|`cxf:inInterceptors` 
|The incoming interceptors for this endpoint.
|A list of `<bean>` or `<ref>`.

|`cxf:inFaultInterceptors` 
|The incoming fault interceptors for this endpoint. 
|A list of `<bean>` or
`<ref>`.

|`cxf:outInterceptors` 
|The outgoing interceptors for this endpoint.
|A list of `<bean>` or `<ref>`.

|`cxf:outFaultInterceptors` 
|The outgoing fault interceptors for this endpoint.
|A list of `<bean>` or `<ref>`.

|`cxf:properties` 
|A properties map supplied to the JAX-WS endpoint.
|See below.

|`cxf:handlers` 
|A JAX-WS handler list which should be supplied to the JAX-WS endpoint.
|See below.

|`cxf:dataBinding` 
|The `DataBinding` to use in the endpoint.
|You can supply this with the Spring `<bean class="MyDataBinding"/>`
syntax.

|`cxf:binding` 
|Specifes which `BindingFactory` to use for this endpoint. 
|You can supply this with the Spring `<bean class="MyBindingFactory"/>` syntax.

|`cxf:features` 
|The features that hold the interceptors for this endpoint. 
|A list of beans or refs

|`cxf:schemaLocations` 
|The schema locations for this endpoint. 
|A list of `schemaLocations`

|`cxf:serviceFactory` 
|The service factory for this endpoint.
|You can supply this with the Spring`<bean class="MyServiceFactory"/>` syntax 

|=======================================================================

You can find more advanced examples that show how to provide interceptors, properties and handlers on the CXF http://cxf.apache.org/docs/jax-ws-configuration.html[JAX-WS
Configuration page].

[NOTE]
====
You can use `cxf:properties` in the spring configuration file to set the `dataFormat` for the camel-cxf endpoint and the `setDefaultBus` properties:
====

.Example: 
[tabs]
====
Java (Quarkus)::
+
[source,java]
----
import org.apache.camel.component.cxf.common.DataFormat;
import org.apache.camel.component.cxf.jaxws.CxfEndpoint;
import jakarta.enterprise.context.SessionScoped;
import jakarta.enterprise.inject.Produces;
import jakarta.inject.Named;

...

@Produces
@SessionScoped
@Named
CxfEndpoint testEndpoint() {
    final CxfEndpoint result = new CxfEndpoint();
    result.setServiceClass(HelloService.class);
    result.setDataFormat(DataFormat.RAW);
    result.setDefaultBus(true);
    result.setAddress("/hello");
    return result;
}
----

XML (Spring)::
+
[source,xml]
----
<cxf:cxfEndpoint id="testEndpoint" address="http://localhost:9000/router"
     serviceClass="org.apache.camel.component.cxf.HelloService"
     endpointName="s:HelloPort"
     serviceName="s:HelloService"
     xmlns:s="http://www.example.com/test">
     <cxf:properties>
       <entry key="dataFormat" value="RAW"/>
       <entry key="setDefaultBus" value="true"/>
     </cxf:properties>
   </cxf:cxfEndpoint>
----
====


include::spring-boot:partial$starter.adoc[]
